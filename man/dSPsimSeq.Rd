% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dSPsimSeq.R
\name{dSPsimSeq}
\alias{dSPsimSeq}
\title{Evaluate the densities in the estimated SPsimSeq object}
\usage{
dSPsimSeq(SPobj, est.parms, force.fit.data = TRUE)
}
\arguments{
\item{SPobj}{The SPsimSeq object, with details retained}

\item{force.fit.data}{a logical value. If TRUE (the default), then observations larger or smaller
than the midpoint of the higher or lower classes (respectively) will be forced to the midpoint of
the higher or lower classes (respectively). This argument is particularly important to avoid
extrapolation problem for observations that are out of the range of the data points (midpoints)
used for the estimation of the SPsimSeq log-linear regression parameters.}

\item{newData}{All information on the data points at which the density should
be evaluated. See details}
}
\value{
a list of estimated densities
}
\description{
Evaluate the densities in the estimated SPsimSeq object
}
\details{
The newData should consist of a matrix or data frame with entries 
"gene", "group" and "batch".
}
\examples{
data("zhang.data.sub")
# filter genes with sufficient expression (important step to avoid bugs)
zhang.counts <- zhang.data.sub$counts[rowSums(zhang.data.sub$counts > 0)>=5, ]
MYCN.status  <- zhang.data.sub$MYCN.status
# simulate data
zhang.counts2 <- zhang.counts[sample(nrow(zhang.counts), 2000), ]
sim.data.bulk <- SPsimSeq(n.sim = 1, s.data = zhang.counts2,
                          group = MYCN.status, n.genes = 2000, batch.config = 1,
                          group.config = c(0.5, 0.5), tot.samples = 20,
                          pDE = 0.1, lfc.thrld = 0.5, result.format = "list",
                          return)
outDens = dSPsimSeq(sim.data.bulk, newData = zhang.counts2[1,])
}
